## 정렬 Sort - 버블, 선택, 삽입 정렬

---

- **단순하지만 비효율적인 정렬**

1. 버블 정렬
2. 선택 정렬
3. 삽입 정렬

---

### 버블 정렬 Bubble Sort

1. 배열의 첫번째 요소부터 마지막 요소까지 반복하면서 인접한 두 요소를 비교
2.  인접한 두 요소가 정렬되지 않은 경우 서로 교환

- 시간 복잡도 
  - 최악 - O(n²)  최선 - O(n)  평균 - O(n²)

- 간단하여 이해하기는 쉬우나 대량 데이터에 대한 성능이 매우 떨어짐

- 안정 정렬 - 동일한 값들이 입력 순서대로 유지

```c
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        for (int j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                // 인접한 두 요소가 정렬되지 않은 경우 서로 교환
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
```

---

### 선택 정렬 Selection Sort

1. 배열에서 가장 작은 요소를 찾아 첫번째 요소와 교환
2. 다음으로 작은 요소를 찾아 두번째 요소와 교환
3. 이 과정을 마지막 요소까지 반복

- 시간복잡도 : O(n²)
- 불안정 정렬 : 동일한 값들이 입력 순서를 유지하지 않음

```c
void selectionSort(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        int min_idx = i; // 가장 작은 요소의 인덱스
        for (int j = i+1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j; // 새로운 가장 작은 요소의 인덱스 업데이트
            }
        }
        // 가장 작은 요소를 현재 위치(i)와 교환
        int temp = arr[min_idx];
        arr[min_idx] = arr[i];
        arr[i] = temp;
    }
}
```





---

### 삽입 정렬 Insertion Sort

1. 배열의 두번째 요소부터 시작, 현재 요소의 앞(왼쪽) 요소들과 비교
2. 현재 요소보다 큰 요소는 오른쪽으로 한칸씩 이동
3. 현재 요소보다 작은 요소를 발견 시 정지하고 그 앞칸(빈칸)에 현재 요소를 삽입
4. 이 과정을 마지막 요소까지 반복

- 시간 복잡도 : O(n²)

- 작은 데이터 세트, 어느정도 정렬있는 세트엔 효율적이고 구현이 간단하나, 반대인 경우엔 최악임

- 안정 정렬 - 동일한 값들이 원래 순서를 유지

```c
void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;

        // 현재 요소를 올바른 위치에 삽입하기 위해 배열의 왼쪽 부분과 비교
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j]; // 현재 요소보다 큰 요소는 오른쪽으로 한칸 이동
            j--;
        }
        arr[j + 1] = key; // 현재 요소보다 작은 값의 앞 칸,빈 칸에 삽입
    }
}
```

