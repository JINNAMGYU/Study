## 동적 계획법 Dynamic Programming

---

- 복잡한 문제를 단순한 하위 문제로 분할하고, 하위 문제의 결과를 저장하여 전체 문제를 해결하는      알고리즘 기법

- **최적 부분 구조** : 큰 문제의 최적 해결 방법이 작은 문제들의 최적 해결 방법으로 구성 가능한 경우

- **중복되는 부분 문제** : 동일한 작은 문제들을 여러 번 반복하여 해결되는 경우



### 접근 방식

1. **Top Down (Memoization)**
   - 문제를 큰 문제에서 작은 문제로 분할하여 **재귀**적으로 해결
   - 하위 문제의 결과를 저장해두고 재사용하여 중복 계산 방지 (**메모이제이션**)

```c
// 예시 - 피보나치 수열

int memo[MAX] // 메모이제이션을 위한 배열
int fib(int n) { // 피보나치 수열을 계산하는 재귀 함수
    if (n <= 1) { // n이 0 또는 1일 경우, n을 반환
        return n;
    }
    
    if (memo[n] != -1) { // 이미 메모된 값이 있으면 그 값을 반환 (-1로 초기화해두어야 함)
        return memo[n];
    }
    memo[n] = fib(n-1) + fib(n-2);  // 메모된 값이 없으면 계산하고 메모 배열에 저장
    return memo[n];
}
```



2. **Bottom Up (Tabulation)**
   - 작은 문제부터 차근차근 해결하여 결과를 테이블에 저장
   - 작은 문제의 결과를 이용하여 점차 큰 문제를 해결

```c
// 예시 - 피보나치 수열
int fib(int n) {  // 피보나치 수열을 계산하는 함수
    if (n <= 1) { // n이 0 또는 1일 경우, n 반환
        return n;
    }
    int dp[n + 1]; // 결과를 저장할 배열을 선언
    dp[0] = 0;     // 초기 조건을 설정합니다.
    dp[1] = 1;
    for (int i = 2; i <= n; i++) { // 반복문을 통해 피보나치 수열을 계산
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n]; // 결과를 반환
}
```