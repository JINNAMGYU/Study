

# 관찰자 패턴 (Observer Pattern) 총정리

## 1. 핵심 정의

> **"어떤 객체의 상태가 변할 때, 그와 연관된 객체들에게 알림을 보내고 자동으로 갱신하게 만드는 패턴"**

객체 간의 의존성을 최소화하면서도(Decoupling) 상태 변화를 실시간으로 전파하기 위한 필수 패턴입니다.

---

## 2. 주요 구성 요소

관찰자 패턴은 크게 두 가지 역할로 나뉩니다.

| 역할 | 명칭 | 설명 |
| --- | --- | --- |
| **발행자** | **Subject (Observable)** | 상태가 변하는 주체. 관찰자(Observer)들의 목록을 관리하고 알림을 보냄. |
| **구독자** | **Observer** | 알림을 대기하는 객체. 알림을 받으면 각자 정의된 로직을 실행. |

---

## 3. 데이터 전달 방식 (Push vs Pull)

알림이 발생했을 때 데이터를 어떻게 넘길 것인가에 대한 전략입니다.

* **Push 모델:** 알림을 보낼 때 구체적인 데이터를 인자(Argument)로 함께 전달.
* *예: `OnHpChanged(float damage, Entity attacker)*`
* 장점: 관찰자가 즉시 데이터를 사용할 수 있음.


* **Pull 모델:** 알림만 보내고, 관찰자가 필요할 때 직접 주체의 데이터를 조회.
* 장점: 관찰자가 필요한 정보만 선택적으로 가져갈 수 있어 유연함.


---

## 4. 실전 엔진 구현 예시 (C# / Unity)

유니티에서는 언어 차원의 `event`와 `Action`을 사용하여 가장 깔끔하게 구현합니다.

```csharp
public class Player : MonoBehaviour {
    // 1. 이벤트 선언 (Subject)
    public event Action<int> OnHpChanged;

    private int hp = 100;

    public void TakeDamage(int damage) {
        hp -= damage;
        // 2. 구독자들에게 알림 (Push 모델)
        OnHpChanged?.Invoke(hp);
    }
}

public class HealthUI : MonoBehaviour {
    // 3. 구독 신청 (Observer)
    private void OnEnable() {
        player.OnHpChanged += UpdateHeartUI;
    }

    // 4. 구독 해제 (중요!)
    private void OnDisable() {
        player.OnHpChanged -= UpdateHeartUI;
    }

    private void UpdateHeartUI(int currentHp) {
        /* UI 갱신 로직 */
    }
}

```

---

## 5. 심화 이슈 및 해결책

### ① 메모리 누수 (Memory Leak)

* **문제:** 관찰자 객체가 파괴되었는데 구독 해지(`-=`)를 하지 않으면, Subject가 이미 파괴된 객체의 메모리 주소를 계속 들고 있게 되어 **메모리 누수**와 **런타임 에러(Crash)**를 유발합니다.
* **해결:** `OnDestroy()`나 `OnDisable()`에서 반드시 구독을 해제하거나, 약한 참조(Weak Reference)를 사용합니다.

### ② 이벤트 연쇄 반응 (Infinite Loop)

* **문제:** A의 이벤트가 B를 트리거하고, B가 다시 A의 상태를 바꿔 또 이벤트를 발생시키는 무한 루프.
* **해결:** 상태 변경 조건문을 엄격히 하거나, **이벤트 큐(Event Queue)**를 도입하여 알림의 시점을 분리합니다.

### ③ 실행 순서의 불확실성

* **문제:** 여러 개의 관찰자가 있을 때 누가 먼저 실행될지 알 수 없습니다.
* **해결:** 순서가 중요하다면 관찰자 패턴 대신 **명령(Command) 패턴**이나 중앙 집중형 **매니저 구조**를 검토해야 합니다.

---

## 6. 장단점 요약

### ✅ 장점

* **낮은 결합도:** `Player` 클래스는 `UI`나 `Sound` 클래스의 존재를 몰라도 됩니다.
* **확장성:** 새로운 시스템(예: 업적 시스템)을 추가할 때 기존 코드를 수정할 필요가 없습니다.

### ❌ 단점

* **흐름 파악의 어려움:** 코드가 흩어져 있어 이벤트가 터졌을 때 어디어디가 반응하는지 한눈에 보기 어렵습니다. (디버깅 난이도 상승)
* **성능 비용:** 관찰자가 너무 많으면 알림을 돌리는 반복문 오버헤드가 발생할 수 있습니다.
