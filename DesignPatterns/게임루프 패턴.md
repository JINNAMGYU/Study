# 게임 루프 (Game Loop)

## 1. 개요

* **의도:** 게임 시간의 흐름을 OS의 이벤트 루프나 사용자 입력에 종속되지 않고, **독자적이고 지속적으로 제어**하기 위한 패턴입니다.
* **핵심:** 유저의 입력이 없더라도 게임 세상은 계속해서 흐르고(AI 이동, 애니메이션 등), 화면은 끊임없이 갱신되어야 합니다.

## 2. 기본 구조

전형적인 게임 루프는 매 프레임마다 다음 세 단계를 무한히 반복합니다.

```cpp
while (processInput()) { // 1. 입력 처리
  update();              // 2. 상태 업데이트
  render();              // 3. 렌더링
}

```

---

## 3. 루프의 진화 (3단계 구현 방식)

책에서는 하드웨어 성능과 모니터 주사율에 따라 발생할 수 있는 문제와 그 해결책을 단계별로 설명합니다.

### ① 고정 시간 간격 없는 루프 (최악)

* **방식:** 컴퓨터가 허용하는 최대 속도로 루프를 돌림.
* **문제:** 컴퓨터 사양이 좋으면 게임이 너무 빨라지고, 사양이 낮으면 너무 느려짐. (성능에 따라 난이도가 달라짐)

### ② 가변 시간 간격 (Variable Time Step)

* **방식:** 지난 프레임부터 지금까지 걸린 시간(, Delta Time)을 측정하여 `update(elapsed)`에 넘겨줌.
* **장점:** 사양에 상관없이 게임 내 물리 시간이 일정하게 흐르는 것처럼 보임.
* **단점:** 하드웨어 사양이 급격히 떨어지면 가 커져서, 캐릭터가 벽을 뚫고 지나가는 등의 **물리 연산 버그(비결정성)**가 발생함.

### ③ 고정 업데이트, 가변 렌더링 (최적)

* **방식:** 물리/로직 업데이트는 **일정한 시간 간격**(초 등)으로 여러 번 혹은 나누어서 실행하고, 렌더링은 가능한 한 빨리 실행함.
* **특징:** 로직의 일관성(물리 안정성)을 유지하면서도 부드러운 화면 전환을 동시에 잡음.

---

## 4. 구현 예시 (고정 시간 업데이트 방식)

책에서 제안하는 가장 안정적인 형태의 의사코드(Pseudo-code)입니다.

```cpp
double previous = getCurrentTime();
double lag = 0.0;
const double MS_PER_UPDATE = 16.67; // 60 FPS 기준 (고정 시간)

while (true) {
  double current = getCurrentTime();
  double elapsed = current - previous;
  previous = current;
  lag += elapsed; // 실제 흐른 시간을 누적

  processInput();

  // 누적된 시간이 고정 간격보다 크면 그만큼 업데이트 반복
  while (lag >= MS_PER_UPDATE) {
    update(); // 물리 및 로직은 항상 일정한 간격으로!
    lag -= MS_PER_UPDATE;
  }

  // 남은 시간(lag) 비율만큼 보간하여 부드럽게 출력
  render(lag / MS_PER_UPDATE); 
}

```

---

## 5. 특징 및 요약

| 구분 | 내용 |
| --- | --- |
| **결정성** | 고정 시간 간격을 사용하면 어떤 PC에서든 동일한 물리 결과를 보장함. |
| **전력 소모** | 루프를 너무 빠르게 돌리면 CPU/GPU 점유율이 100%가 되어 배터리 소모가 심해짐. |
| **플랫폼 종속성** | 현대 엔진(유니티, 언리얼)은 이 루프를 엔진 깊숙한 곳에서 관리하며 사용자에게는 `Update()`나 `FixedUpdate()`라는 인터페이스로 제공함. |

> **핵심 팁:** 유니티의 `Update()`는 프레임마다 호출되는 **가변 시간 간격**이며, `FixedUpdate()`는 물리 연산을 위한 **고정 시간 간격** 루프의 전형적인 예시입니다.
