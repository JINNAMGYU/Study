# 이중 버퍼 (Double Buffer)

## 1. 개요

* **의도:** 일련의 순차적인 작업들이 동시에 일어나는 것처럼 보이게 하여, 변경 중인 중간 상태가 노출되지 않도록 하는 패턴입니다.
* **비유:** 연극 무대 장치를 바꿀 때 관객이 보지 못하도록 커튼을 치고 작업을 완료한 후, 한 번에 커튼을 걷어 완성된 무대를 보여주는 것과 같습니다.

## 2. 작동 원리

1. **전면 버퍼(Front Buffer):** 현재 화면에 출력되고 있는 읽기 전용 데이터.
2. **후면 버퍼(Back Buffer):** 다음 프레임을 위해 열심히 수정(쓰기) 중인 데이터.
3. **플립(Flip/Swap):** 후면 버퍼의 작업이 끝나면, 전면과 후면의 역할을 바꿉니다. (보통 포인터만 교체)

---

## 3. 간단한 구현 예제 (C++)

이 코드는 그래픽 API 없이도 이중 버퍼의 원리(상태 전이)를 이해할 수 있는 구조입니다.

```cpp
#include <iostream>
#include <vector>

class FrameBuffer {
public:
    void clear() { /* 화면 지우기 로직 */ }
    void draw(int x, int y) { std::cout << x << "," << y << "에 점 찍기\n"; }
};

class Scene {
public:
    Scene() {
        // 두 개의 버퍼 준비
        buffers[0] = new FrameBuffer();
        buffers[1] = new FrameBuffer();
        current_ = buffers[0]; // 현재 보여지는 쪽
        next_ = buffers[1];    // 그릴 쪽
    }

    // 1. 다음 프레임을 그리는 단계 (후면 버퍼에 작업)
    void render() {
        next_->clear();
        next_->draw(10, 20); // 예시 좌표
    }

    // 2. 버퍼를 교체하는 단계 (플립)
    void swap() {
        FrameBuffer* temp = current_;
        current_ = next_;
        next_ = temp;
        std::cout << "--- 버퍼 스왑 완료! ---\n";
    }

    FrameBuffer* getBuffer() { return current_; }

private:
    FrameBuffer* buffers[2];
    FrameBuffer* current_; // 전면 버퍼 (Front)
    FrameBuffer* next_;    // 후면 버퍼 (Back)
};

int main() {
    Scene gameScene;

    while (true) { // 게임 루프
        gameScene.render(); // 뒷면에 그리기
        gameScene.swap();   // 화면 전환
    }
    return 0;
}

```

---

## 4. 특징 및 주의사항

| 장점 | 단점/주의사항 |
| --- | --- |
| **결과물 처리:** 중간 과정(깜빡임 등) 없이 완성된 결과만 노출함. | **메모리 사용:** 버퍼가 두 개이므로 메모리 사용량이 두 배가 됨. |
| **속도:** 데이터 복사가 아닌 포인터 교체 방식()으로 매우 빠름. | **동기화 문제:** GPU와 모니터의 갱신 속도가 다르면 티어링(Tearing) 발생 가능. |

### 💡 활용 팁

* **그래픽스 외 활용:** 모든 유닛이 동시에 이동해야 하는 턴제 게임이나 물리 시뮬레이션에서, '이전 위치'를 참조하면서 '새 위치'를 계산해야 할 때 이 패턴을 사용하여 연산 순서에 따른 불공정함을 방지할 수 있습니다.
