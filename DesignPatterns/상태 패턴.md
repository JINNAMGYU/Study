# 상태 패턴 (State Pattern)

## 1. 개요

상태 패턴은 객체의 내부 상태에 따라 행동이 달라질 때  
조건문(if/switch)을 제거하고 상태를 객체로 분리하는 패턴이다.

> 핵심: 상태를 값(enum)이 아니라 객체로 다룬다.

---

## 2. 기존 방식의 문제점

```cpp
if (state == STANDING) {
    if (input == JUMP) state = JUMPING;
}
else if (state == JUMPING) {
    if (input == LAND) state = STANDING;
}
````

###  문제

* 조건문 증가
* 상태 전이 버그
* 유지보수 어려움
* 상태 조합 폭발

---

## 3. 상태 패턴 기본 구조

### 구조

Context → State 인터페이스 → ConcreteState들

```
Player
 └── State
      ├── StandingState
      └── JumpingState
```

---

## 4. 기본 예제 코드

### 1️⃣ State 인터페이스

```cpp
class State {
public:
    virtual void handleInput(class Player& player, int input) = 0;
    virtual ~State() {}
};
```

---

### 2️⃣ 구체 상태

```cpp
class StandingState : public State {
public:
    void handleInput(Player& player, int input) override {
        if (input == 1) {
            player.setState(new JumpingState());
        }
    }
};
```

---

### 3️⃣ Context

```cpp
class Player {
private:
    State* state;

public:
    Player(State* initial) : state(initial) {}

    void handleInput(int input) {
        state->handleInput(*this, input);
    }

    void setState(State* newState) {
        state = newState;
    }
};
```

---

## 5. 장점

✅ 조건문 제거
✅ 상태별 책임 분리
✅ 확장에 강함 (OCP)
✅ 상태 전이 명확

---

## 6. 단점

❌ 상태 클래스 수 증가
❌ 상태 조합 폭발
❌ 구조 복잡해짐

---

# 🔥 상태 패턴 확장 기법

---

# 7. 병행 상태 기계 (Concurrent FSM)

## 문제

이동 + 공격 + 감정 상태를 하나로 만들면 조합 폭발

## 해결

FSM을 독립적으로 분리

```
Player
 ├── MovementFSM
 ├── CombatFSM
 └── EmotionFSM
```

### 예시

```cpp
class Player {
    MovementFSM movement;
    CombatFSM combat;

public:
    void update() {
        movement.update();
        combat.update();
    }
};
```

### ✔ 장점

* 조합 폭발 방지
* 관심사 분리

---

# 8. 계층형 상태 기계 (Hierarchical FSM)

## 문제

Ground 상태의 공통 로직 중복 발생

## 해결

상태를 상속 구조로 구성

```
State
 ├── GroundedState
 │     ├── Idle
 │     └── Run
 └── AirborneState
       ├── Jump
       └── Dive
```

### 예시

```cpp
class GroundedState : public State {
public:
    void applyGravity(Player& player) {
        player.y -= 1;
    }
};

class IdleState : public GroundedState {
public:
    void handleInput(Player& player, int input) override {
        applyGravity(player);
    }
};
```

### ✔ 장점

* 공통 로직 재사용
* 코드 중복 감소

---

# 9. 푸시다운 오토마타 (Pushdown Automaton)

## 문제

피격 후 이전 상태로 복귀해야 하는 상황

## 해결

상태를 스택으로 관리

### 구조

```
Top -> Stun
        Attack
        Run
```

### 예시

```cpp
#include <stack>

class Player {
    std::stack<State*> stateStack;

public:
    void pushState(State* state) {
        stateStack.push(state);
    }

    void popState() {
        stateStack.pop();
    }

    void handleInput(int input) {
        stateStack.top()->handleInput(*this, input);
    }
};
```

### ✔ 장점

* 이전 상태 자동 복귀
* 메뉴, 일시정지 구현에 적합

---

# 10. 세 가지 확장 비교

| 기법      | 해결 문제    | 사용 예     |
| ------- | -------- | -------- |
| 병행 FSM  | 상태 조합 폭발 | 이동/공격 분리 |
| 계층형 FSM | 중복 코드    | 공통 물리 처리 |
| 푸시다운    | 이전 상태 복귀 | 메뉴, 경직   |

---

# 11. 실무 사용 전략

대형 게임에서는 보통:

* 병행 FSM + 계층형 FSM 혼합
* UI는 푸시다운 구조
* AI는 FSM + Behavior Tree 혼합
