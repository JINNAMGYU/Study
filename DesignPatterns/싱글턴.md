# 싱글턴 (Singleton)
---

## 1. 싱글턴 패턴의 정의

싱글턴 패턴은 클래스가 **단 하나의 인스턴스**만 갖도록 보장하고, 이에 대한 **전역적인 접근점**을 제공하는 패턴입니다.

### 구현의 특징

* **private 생성자**: 외부에서 객체를 생성하지 못하게 막습니다.
* **static 인스턴스**: 클래스 내부에 유일한 인스턴스를 보관합니다.
* **static 접근 메서드**: 어디서든 인스턴스에 접근할 수 있는 통로(`Instance()`)를 제공합니다.
```
class FileSystem {
public:
    static FileSystem& instance() {
        // 지역 정적 변수는 처음 호출될 때 딱 한 번 초기화됨 (C++11 이상 스레드 안전)
        static FileSystem* instance = new FileSystem();
        return *instance;
    }

private:
    FileSystem() {} // 외부 생성 방지
};
```
---

## 2. 왜 싱글턴을 사용하는가? (장점)

1. **하나만 있어야 하는 객체 관리**: 파일 시스템, 오디오 디바이스, 로그 시스템 등 여러 개가 생기면 곤란한 자원을 안전하게 관리합니다.
2. **전역 접근의 편리함**: 어디서든 `GameManager.Instance.Score` 처럼 접근할 수 있어 코딩이 물리적으로 편해집니다.
3. **게으른 초기화 (Lazy Initialization)**: 객체가 실제로 필요할 때까지 생성을 미룰 수 있어 시작 시 부하를 줄입니다.

---

## 3. 싱글턴의 치명적인 문제점 (단점)

* **전역 변수의 폐해**: 코드 어디서든 값을 수정할 수 있어 버그 발생 시 추적이 매우 어렵습니다.
* **강한 결합도 (Coupling)**: 싱글턴을 호출하는 모든 클래스는 해당 싱글턴에 의존하게 됩니다. 나중에 구조를 바꾸기가 매우 힘들어집니다.
* **멀티스레드 위험성**: 여러 스레드에서 동시에 인스턴스에 접근하거나 생성할 때 레이스 컨디션(Race Condition)이 발생할 수 있습니다.
* **테스트의 어려움**: 전역 상태를 공유하므로 단위 테스트(Unit Test)를 수행할 때마다 이전 테스트의 잔재가 남을 수 있습니다.

---

## 4. 싱글턴을 피하는 대안들

1. **클래스가 꼭 필요한가?**: 단순한 헬퍼 함수라면 static 함수만 모아둔 네임스페이스나 클래스가 나을 수 있습니다.
2. **객체를 인자로 전달하기**: 필요한 객체를 생성자나 메서드의 파라미터로 직접 넘겨주세요. 의존성이 명확해집니다.
3. **상위 클래스에서 제공하기**: 부모 클래스(예: `Entity`)에 멤버 변수로 두어 자식들이 공유하게 합니다.
4. **서비스 로커 (Service Locator)**: 전역적인 접근은 허용하되, 구체적인 구현체를 유연하게 갈아끼울 수 있는 구조를 취합니다.

---
