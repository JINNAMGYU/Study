

# 경량 패턴 (Flyweight Pattern)

## 1. 핵심 정의

> **"모두가 똑같이 가지고 있는 건 한 곳에 모으고, 나만 가진 것만 들고 있자."**

객체의 개수가 많을 때, 중복되는 데이터를 공유하여 **메모리(RAM/VRAM) 사용량을 최적화**하는 구조적 패턴

---

## 2. 객체 데이터

경량 패턴에선 객체의 데이터를 두 종류로 나눔

| 구분 | 고유 상태 (Intrinsic) | 외부 상태 (Extrinsic) |
| --- | --- | --- |
| **특징** | 인스턴스마다 **변하지 않는** 공통 데이터 | 인스턴스마다 **달라지는** 개별 데이터 |
| **저장 위치** | 별도의 공유 객체 (Flyweight) | 각 개별 객체 내부에 저장 |
| **예시** | 모델 데이터, 텍스처, 기본 공격력 | 현재 좌표(), 현재 체력, 각도 |

---

## 3. 게임 엔진에서의 실제 모습

엔진은 하드웨어 최적화를 담당하고, 개발자는 데이터 구조 최적화를 담당합니다.

### ① 엔진이 해주는 것 (Render 최적화)

* **GPU Instancing:** 동일한 메쉬와 재질을 가진 물체를 하나의 명령으로 처리하여 Draw Call을 줄입니다.
* **리소스 관리:** 같은 이미지 파일을 여러 번 로드하지 않고 메모리 상의 같은 주소를 참조하게 합니다.

### ② 개발자가 해야 하는 것 (Logic 최적화)

유니티와 언리얼에서 제공하는 기능을 활용해 **데이터 공유 구조**를 직접 짜야 합니다.

* **Unity:** `ScriptableObject`를 활용해 수천 명의 유닛이 하나의 데이터 에셋을 참조하게 설계.
* **Unreal:** `UDataAsset`을 사용하여 무거운 설정값을 액터(Actor)로부터 분리.

---

## 4. 코드 설계 구조 (C# / Unity 예시)

```csharp
// [고유 상태] 공유할 무거운 데이터
[CreateAssetMenu]
public class UnitData : ScriptableObject {
    public string unitName;
    public float maxHp;
    public GameObject modelPrefab; // 무거운 리소스
}

// [외부 상태] 실제 월드에 배치될 가벼운 객체
public class Unit : MonoBehaviour {
    public UnitData data;    // 공유 데이터 참조 (포인터 4~8바이트)
    
    private float currentHp; // 개별 데이터
    private Vector3 position; // 개별 데이터
}

```

---

## 5. 경량 패턴의 장단점

### ✅ 장점

* **메모리 절감:** 수백 MB의 데이터를 몇 KB 수준으로 압축하는 효과가 있습니다.
* **성능 향상:** 메모리 사용량이 줄어들면 CPU 캐시 적중률이 높아지고 로딩 속도가 빨라집니다.

### ❌ 단점 (주의사항)

* **런타임 수정의 제약:** 공유 객체(Flyweight)의 값을 수정하면 **그것을 참조하는 모든 객체의 값이 동시에 변합니다.** (예: 나무 모델 색을 바꾸면 숲 전체가 변함)
* **구조적 복잡도:** 데이터를 분리하고 참조하는 과정에서 코드가 조금 더 복잡해질 수 있습니다.

---

1. 이 패턴이 적용된 **더 구체적인 C++ 예제 코드**가 필요하신가요?
2. 아니면 1주차 Day 1 주제인 **`vector`의 `reserve`와 `push_back` 최적화**로 넘어갈까요?
